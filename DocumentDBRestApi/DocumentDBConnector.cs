// Code generated by Microsoft (R) AutoRest Code Generator 0.9.7.0
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using DocumentDBRestApi.Models;
using Microsoft.Rest;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace DocumentDBRestApi
{
    /// <summary>
    /// </summary>
    public class DocumentDbConnector : ServiceClient<DocumentDbConnector>, IDocumentDbConnector
    {
        /// <summary>
        ///     Initializes a new instance of the DocumentDbConnector class.
        /// </summary>
        public DocumentDbConnector()
        {
            var account = $"https://{DocumentDbAccount}documents.azure.com:443/dbs";
            BaseUri = new Uri(account);
        }

        /// <summary>
        ///     Initializes a new instance of the DocumentDbConnector class.
        /// </summary>
        /// <param name='handlers'>
        ///     Optional. The set of delegating handlers to insert in the http
        ///     client pipeline.
        /// </param>
        public DocumentDbConnector(params DelegatingHandler[] handlers)
            : base(handlers)
        {
            var account = $"https://{DocumentDbAccount}documents.azure.com:443/dbs";
            BaseUri = new Uri(account);
        }

        /// <summary>
        ///     Initializes a new instance of the DocumentDbConnector class.
        /// </summary>
        /// <param name='rootHandler'>
        ///     Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        ///     Optional. The set of delegating handlers to insert in the http
        ///     client pipeline.
        /// </param>
        public DocumentDbConnector(HttpClientHandler rootHandler, params DelegatingHandler[] handlers)
            : base(rootHandler, handlers)
        {
            var account = $"https://{DocumentDbAccount}documents.azure.com:443/dbs";
            BaseUri = new Uri(account);
        }

        /// <summary>
        ///     Initializes a new instance of the DocumentDbConnector class.
        /// </summary>
        /// <param name='baseUri'>
        ///     Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        ///     Optional. The set of delegating handlers to insert in the http
        ///     client pipeline.
        /// </param>
        public DocumentDbConnector(Uri baseUri, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (baseUri == null)
                throw new ArgumentNullException(nameof(baseUri));
            BaseUri = baseUri;
        }

        /// <summary>
        ///     Initializes a new instance of the DocumentDbConnector class.
        /// </summary>
        /// <param name='credentials'>
        ///     Required. Credentials for authenticating with the service.
        /// </param>
        /// <param name='handlers'>
        ///     Optional. The set of delegating handlers to insert in the http
        ///     client pipeline.
        /// </param>
        public DocumentDbConnector(ServiceClientCredentials credentials, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (credentials == null)
                throw new ArgumentNullException(nameof(credentials));
            Credentials = credentials;

            Credentials?.InitializeServiceClient(this);
        }

        /// <summary>
        ///     Initializes a new instance of the DocumentDbConnector class.
        /// </summary>
        /// <param name='baseUri'>
        ///     Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        ///     Required. Credentials for authenticating with the service.
        /// </param>
        /// <param name='handlers'>
        ///     Optional. The set of delegating handlers to insert in the http
        ///     client pipeline.
        /// </param>
        public DocumentDbConnector(Uri baseUri, ServiceClientCredentials credentials,
            params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException(nameof(baseUri));
            }
            if (credentials == null)
            {
                throw new ArgumentNullException(nameof(credentials));
            }
            BaseUri = baseUri;
            Credentials = credentials;

            Credentials?.InitializeServiceClient(this);
        }

        /// <summary>
        ///     Get an Attachment from document
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridDoc'>
        ///     Required. The Document Id
        /// </param>
        /// <param name='ridAttch'>
        ///     Required. The Attachment Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        ///     .
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.           example -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        Task<HttpOperationResponse<AttachmentRaw>> IDocumentDbConnector.GetAttachementWithOperationResponseAsync(
            string ridDB, string ridColl, string ridDoc, string ridAttch,
            string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken)
        {
            return GetAttachementWithOperationResponseAsync(ridDB, ridColl, ridDoc, ridAttch, authorization, userAgent,
                xMSDate, xMSVersion, cancellationToken);
        }


        /// <summary>
        ///     Create an Attachment
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridDoc'>
        ///     Required. The Document Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<AttachmentResponse>> CreateAttachementWithOperationResponseAsync(
            string ridDB, string ridColl, string ridDoc, AttachmentRaw request, string authorization, string userAgent,
            string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("ridDoc", ridDoc);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "CreateAttachementAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            url = url + "/attachments";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request
            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.Conflict && statusCode != HttpStatusCode.RequestEntityTooLarge)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<AttachmentResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new AttachmentResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }



        /// <summary>
        ///     Create a new Collection
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example -
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='id'>
        ///     Required. This is a user settable property. It is the unique name
        ///     that identifies the collection
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Collection>> CreateCollectionWithOperationResponseAsync(string ridDB,
            string authorization, string xMSDate, string xMSVersion, CustomBodyCollection id,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (id == null)
            {
                throw new ArgumentNullException(nameof(id));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                tracingParameters.Add("id", id);
                ServiceClientTracing.Enter(invocationId, this, "CreateCollectionAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request
            var requestDoc = id.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };

                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Collection>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Collection();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. For creating a database, the Content-Type header must be
        ///     `<c>application/json</c>`.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='id'>
        ///     Required. This is a user settable property. It is the unique name
        ///     that identifies the collection
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Database>> CreateDatabaseWithOperationResponseAsync(
            string authorization, string contentType, string xMSDate, CustomBodyCollection id,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (id == null)
            {
                throw new ArgumentNullException(nameof(id));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"xMSDate", xMSDate},
                    {"id", id}
                };
                ServiceClientTracing.Enter(invocationId, this, "CreateDatabaseAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("x-ms-date", xMSDate);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = id.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.Created && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.Conflict)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Database>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.Created)
            {
                var resultModel = new Database();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Create a new Document
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Document>> CreateDocumentWithOperationResponseAsync(string ridDB,
            string ridColl, CustomBody request, string authorization, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"request", request},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "CreateDocumentAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Document>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Document();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Create a User
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request..
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<User>> CreateUserWithOperationResponseAsync(string ridDB, User request,
            string authorization, string contentType, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "CreateUserAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.Created && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.Conflict)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<User>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.Created)
            {
                var resultModel = new User();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Delete a Collection
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeleteCollectionWithOperationResponseAsync(string ridDB,
            string ridColl, string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "DeleteCollectionAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Delete,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.NoContent && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<object>
            {
                Request = httpRequest,
                Response = httpResponse,
                Body = null
            };

            // Deserialize Response

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Delete a Database
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>{user agent name}/{version}</c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeleteDatabaseWithOperationResponseAsync(string ridDB,
            string authorization, string contentType, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "DeleteDatabaseAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Delete,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.NoContent && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<object>
            {
                Request = httpRequest,
                Response = httpResponse,
                Body = null
            };

            // Deserialize Response


            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Delete a Document
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridDoc'>
        ///     Required. The Document Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this
        ///     operation.<c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeleteDocumentWithOperationResponseAsync(string ridDB,
            string ridColl, string ridDoc, string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "DeleteDocumentAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Delete,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.NoContent && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<object>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response

            result.Body = null;

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     To delete a permission resource, perform a DELETE operation on that
        ///     permission resource
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridPerm'>
        ///     Required. The Permission Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example:
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeletePermissionWithOperationResponseAsync(string ridDB,
            string ridPerm, string ridUser, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridPerm == null)
            {
                throw new ArgumentNullException(nameof(ridPerm));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridPerm", ridPerm},
                    {"ridUser", ridUser},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "DeletePermissionAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            url = url + "/permissions/";
            url = url + Uri.EscapeDataString(ridPerm);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Delete,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.NoContent && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<object>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response

            result.Body = null;

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Delete a User
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation. example:
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.          example -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeleteUserWithOperationResponseAsync(string ridDB,
            string ridUser, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridUser", ridUser},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "DeleteUserAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Delete,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<object>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response

            result.Body = null;

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Execute a Stored Procedure
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridProc'>
        ///     Required. The Procedure Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Required. The Content-Type header must be
        ///     application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.          example - :
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> ExecuteStoredProcedureWithOperationResponseAsync(
            string ridDB, string ridColl, string ridProc, QueryRequest request, string authorization, string contentType,
            bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridProc == null)
            {
                throw new ArgumentNullException(nameof(ridProc));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridProc", ridProc},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan},
                    {"xMSDocumentdbIsquery", xMSDocumentdbIsquery},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ExecuteStoredProcedureAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/sprocs/";
            url = url + Uri.EscapeDataString(ridProc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResponseBody>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Get an Attachment from document
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridDoc'>
        ///     Required. The Document Id
        /// </param>
        /// <param name='ridAttch'>
        ///     Required. The Attachment Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        ///     .
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.           example -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<AttachmentRaw>> GetAttachementWithOperationResponseAsync(string ridDB,
            string ridColl, string ridDoc, string ridAttch, string authorization, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (ridAttch == null)
            {
                throw new ArgumentNullException(nameof(ridAttch));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"ridAttch", ridAttch},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetAttachementAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "//";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            url = url + "/attachments/";
            url = url + Uri.EscapeDataString(ridAttch);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.Conflict && statusCode != HttpStatusCode.RequestEntityTooLarge)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<AttachmentRaw>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new AttachmentRaw();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Get a Collection
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        ///     .
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.  example -
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Collection>> GetCollectionByIdWithOperationResponseAsync(string ridDB,
            string ridColl, string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetCollectionByIdAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Collection>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Collection();
                JToken responseDoc = null;
                if (!string.IsNullOrEmpty(responseContent))
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Retrieve a database resource by Id
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be `application/json`.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        ///     .
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='xMSGatewayversion'>
        ///     Required.
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Database>> GetDatabaseByIdWithOperationResponseAsync(string ridDB,
            string authorization, string contentType, string userAgent, string xMSDate, string xMSVersion,
            string xMSGatewayversion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (xMSGatewayversion == null)
            {
                throw new ArgumentNullException(nameof(xMSGatewayversion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion},
                    {"xMSGatewayversion", xMSGatewayversion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetDatabaseByIdAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-gatewayversion", xMSGatewayversion);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Database>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Database();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     List Databases
        /// </summary>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is `
        ///     <c>
        ///         >{user agent
        ///         name}/{version}
        ///     </c>
        ///     `.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.  `Fri, 08 Apr 2015 03:52:31 GMT`
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='xMSGatewayversion'>
        ///     Required. The Microsft Date Gateway version
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<DatabaseCollection>>> GetDatabaseListWithOperationResponseAsync(
            string authorization, string userAgent, string xMSDate, string xMSVersion, string xMSGatewayversion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (xMSGatewayversion == null)
            {
                throw new ArgumentNullException(nameof(xMSGatewayversion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion},
                    {"xMSGatewayversion", xMSGatewayversion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetDatabaseListAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-gatewayversion", xMSGatewayversion);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null

                };
                

                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<IList<DatabaseCollection>>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                IList<DatabaseCollection> resultModel = new List<DatabaseCollection>();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel = DatabaseCollectionCollection.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Get a Document.
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridDoc'>
        ///     Required. The Document Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Document>> GetDocumentByIdWithOperationResponseAsync(string ridDB,
            string ridColl, string ridDoc, string authorization, string userAgent, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetDocumentByIdAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Document>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Document();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='databaseaccount'>
        ///     Required. The Database Account Name
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation. example:
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<Offer>>> GetListOfOffersWithOperationResponseAsync(
            string databaseaccount, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (databaseaccount == null)
            {
                throw new ArgumentNullException(nameof(databaseaccount));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"databaseaccount", databaseaccount},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetListOfOffersAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(databaseaccount);
            url = url + ".documents.azure.com/offers";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<IList<Offer>>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                IList<Offer> resultModel = new List<Offer>();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel = OfferCollection.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Get a list of users resource of a particular database
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.          example -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<User>>> GetListOfUsersWithOperationResponseAsync(string ridDB,
            string authorization, string contentType, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "GetListOfUsersAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<IList<User>>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                IList<User> resultModel = new List<User>();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel = UserCollection.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='ridOffer'>
        ///     Required. The Offer Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation. example:
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example:
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Offer>> GetOfferWithOperationResponseAsync(string ridOffer,
            string authorization, string contentType, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridOffer == null)
            {
                throw new ArgumentNullException(nameof(ridOffer));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridOffer", ridOffer);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "GetOfferAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/offers/";
            url = url + Uri.EscapeDataString(ridOffer);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Offer>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Offer();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Performing a GET operation on a specific permission resource
        ///     retrieves the permission properties, including the token, for the
        ///     particular permission. A new resource token is created every time
        ///     a GET is invoked on the permission resource. This new token has
        ///     the default validity period of one hour, unless it is overridden.
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='ridPerm'>
        ///     Required. The Permission Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation. example:
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is {user agent name}/{version}.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example-
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Permission>> GetPermissionWithOperationResponseAsync(string ridDB,
            string ridUser, string ridPerm, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (ridPerm == null)
            {
                throw new ArgumentNullException(nameof(ridPerm));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridUser", ridUser);
                tracingParameters.Add("ridPerm", ridPerm);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "GetPermissionAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            url = url + "/permissions/";
            url = url + Uri.EscapeDataString(ridPerm);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.NotFound &&
                statusCode != HttpStatusCode.MethodNotAllowed && statusCode != HttpStatusCode.Conflict)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Permission>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Permission();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Get a User
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.          example -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<User>> GetUserByIdWithOperationResponseAsync(string ridDB,
            string ridUser, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridUser", ridUser);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "GetUserByIdAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<User>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new User();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     List Collections
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        ///     .
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example -
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<Collection>>> ListCollectionsWithOperationResponseAsync(
            string ridDB, string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "ListCollectionsAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Unauthorized &&
                statusCode != HttpStatusCode.Forbidden)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<IList<Collection>>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                IList<Collection> resultModel = new List<Collection>();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel = CollectionCollection.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     List Documents
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<Document>>> ListDocumentsWithOperationResponseAsync(string ridDB,
            string ridColl, string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "ListDocumentsAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<IList<Document>>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                IList<Document> resultModel = new List<Document>();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel = DocumentCollection.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Must be set to application/query+json
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required. Required. This property must be set to true
        /// </param>
        /// <param name='xMSMaxItemCount'>
        ///     Required. To page through a result set, set this header to the
        ///     maximum number for items to be returned back in a single page.
        ///     <remarks>Range 1 - 1000 Default value = 100</remarks>
        /// </param>
        /// <param name='xMSContinuation'>
        ///     Required. To navigate to the next page of items, set this header to
        ///     the continuation token for the next page.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required. Use an index scan to process the query if the right index
        ///     path of type is not available.
        /// </param>
        /// <param name='xMSSessionToken'>
        ///     Required. The session token for the request. Used for session
        ///     consistency
        /// </param>
        /// <param name='accept'>
        ///     Required. Optional. At the moment, DocumentDB always returns the
        ///     response payload in standard JSON format. The client must be able
        ///     to accept the response body in standard JSON format
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResourceResponseBody>>
            QueryCollectionResourceWithOperationResponseAsync(string ridDB, string ridColl, QueryRequest request,
                string authorization, string userAgent, string xMSDate, string xMSVersion, string contentType,
                bool xMSDocumentdbIsquery, string xMSMaxItemCount, string xMSContinuation,
                bool? xMSDocumentdbQueryEnableScan, string xMSSessionToken, string accept,
                CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (xMSMaxItemCount == null)
            {
                throw new ArgumentNullException(nameof(xMSMaxItemCount));
            }
            if (xMSContinuation == null)
            {
                throw new ArgumentNullException(nameof(xMSContinuation));
            }
            if (xMSDocumentdbQueryEnableScan == null)
            {
                throw new ArgumentNullException(nameof(xMSDocumentdbQueryEnableScan));
            }
            if (xMSSessionToken == null)
            {
                throw new ArgumentNullException(nameof(xMSSessionToken));
            }
            if (accept == null)
            {
                throw new ArgumentNullException(nameof(accept));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("xMSDocumentdbIsquery", xMSDocumentdbIsquery);
                tracingParameters.Add("xMSMaxItemCount", xMSMaxItemCount);
                tracingParameters.Add("xMSContinuation", xMSContinuation);
                tracingParameters.Add("xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan);
                tracingParameters.Add("xMSSessionToken", xMSSessionToken);
                tracingParameters.Add("accept", accept);
                ServiceClientTracing.Enter(invocationId, this, "QueryCollectionResourceAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Accept", accept);
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-continuation", xMSContinuation);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.Value.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-max-item-count", xMSMaxItemCount);
            httpRequest.Headers.Add("x-ms-session-token", xMSSessionToken);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResourceResponseBody>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResourceResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use
        ///     <c>2015-08-06</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Must be set to application/query+json
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required. Required. This property must be set to true
        /// </param>
        /// <param name='xMSMaxItemCount'>
        ///     Required. To page through a result set, set this header to the
        ///     maximum number for items to be returned back in a single page.
        ///     <remarks>Range 1 - 1000 Default value = 100</remarks>
        /// </param>
        /// <param name='xMSContinuation'>
        ///     Required. To navigate to the next page of items, set this header to
        ///     the continuation token for the next page.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required. Use an index scan to process the query if the right index
        ///     path of type is not available.
        /// </param>
        /// <param name='xMSSessionToken'>
        ///     Required. The session token for the request. Used for session
        ///     consistency
        /// </param>
        /// <param name='accept'>
        ///     Required. Optional. At the moment, DocumentDB always returns the
        ///     response payload in standard JSON format. The client must be able
        ///     to accept the response body in standard JSON format
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResourceResponseBody>>
            QueryDocumentResourceWithOperationResponseAsync(string ridDB, string ridColl, QueryRequest request,
                string authorization, string userAgent, string xMSDate, string xMSVersion, string contentType,
                bool xMSDocumentdbIsquery, string xMSMaxItemCount, string xMSContinuation,
                bool? xMSDocumentdbQueryEnableScan, string xMSSessionToken, string accept,
                CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (xMSMaxItemCount == null)
            {
                throw new ArgumentNullException(nameof(xMSMaxItemCount));
            }
            if (xMSContinuation == null)
            {
                throw new ArgumentNullException(nameof(xMSContinuation));
            }
            if (xMSDocumentdbQueryEnableScan == null)
            {
                throw new ArgumentNullException(nameof(xMSDocumentdbQueryEnableScan));
            }
            if (xMSSessionToken == null)
            {
                throw new ArgumentNullException(nameof(xMSSessionToken));
            }
            if (accept == null)
            {
                throw new ArgumentNullException(nameof(accept));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("xMSDocumentdbIsquery", xMSDocumentdbIsquery);
                tracingParameters.Add("xMSMaxItemCount", xMSMaxItemCount);
                tracingParameters.Add("xMSContinuation", xMSContinuation);
                tracingParameters.Add("xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan);
                tracingParameters.Add("xMSSessionToken", xMSSessionToken);
                tracingParameters.Add("accept", accept);
                ServiceClientTracing.Enter(invocationId, this, "QueryDocumentResourceAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/doc";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Accept", accept);
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-continuation", xMSContinuation);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.Value.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-max-item-count", xMSMaxItemCount);
            httpRequest.Headers.Add("x-ms-session-token", xMSSessionToken);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResourceResponseBody>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResourceResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='databaseaccount'>
        ///     Required. The Database Account Name
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation. example:
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example:
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='contentType'>
        ///     Required. Required. The Content-Type header must be
        ///     application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required.
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> QueryOfferWithOperationResponseAsync(
            string databaseaccount, QuerySql request, string authorization, string userAgent, string xMSDate,
            string xMSVersion, string contentType, bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (databaseaccount == null)
            {
                throw new ArgumentNullException(nameof(databaseaccount));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("databaseaccount", databaseaccount);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan);
                tracingParameters.Add("xMSDocumentdbIsquery", xMSDocumentdbIsquery);
                ServiceClientTracing.Enter(invocationId, this, "QueryOfferAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(databaseaccount);
            url = url + ".documents.azure.com/offers";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResponseBody>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Query a Permission
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='request'>
        ///     Required. The Request Body
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Required. The Content-Type header must be
        ///     application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example -
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> QueryPermissionWithOperationResponseAsync(
            string ridDB, string ridUser, QueryRequest request, string authorization, string contentType,
            bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridUser", ridUser);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan);
                tracingParameters.Add("xMSDocumentdbIsquery", xMSDocumentdbIsquery);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "QueryPermissionAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            url = url + "/permissions";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResponseBody>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Query a Trigger
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='contentType'>
        ///     Required. Required. The Content-Type header must be
        ///     application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required.
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.       example -
        ///     <example>
        ///         Fri,
        ///         08 Apr 2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> QueryTriggerWithOperationResponseAsync(string ridDB,
            string ridColl, string contentType, bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery,
            QueryRequest request, string authorization, string userAgent, string xMSDate, string xMSVersion,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan);
                tracingParameters.Add("xMSDocumentdbIsquery", xMSDocumentdbIsquery);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "QueryTriggerAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/trigger";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResponseBody>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Query a UDF
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Required. The Content-Type header must be
        ///     application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        ///     Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        ///     Required.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example:
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> QueryUdfWithOperationResponseAsync(string ridDB,
            string ridColl, QueryRequest request, string authorization, string contentType,
            bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("contentType", contentType);
                tracingParameters.Add("xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan);
                tracingParameters.Add("xMSDocumentdbIsquery", xMSDocumentdbIsquery);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "QueryUdfAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/udf";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan",
                xMSDocumentdbQueryEnableScan.ToString().ToLower());
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<QueryResponseBody>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new QueryResponseBody();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Register a Stored Procedure
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        ///     .
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.          example -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<StoredProcedure>> RegisterStoredProcedureWithOperationResponseAsync(
            string ridDB, string ridColl, QueryRequest request, string authorization, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("ridDB", ridDB);
                tracingParameters.Add("ridColl", ridColl);
                tracingParameters.Add("request", request);
                tracingParameters.Add("authorization", authorization);
                tracingParameters.Add("userAgent", userAgent);
                tracingParameters.Add("xMSDate", xMSDate);
                tracingParameters.Add("xMSVersion", xMSVersion);
                ServiceClientTracing.Enter(invocationId, this, "RegisterStoredProcedureAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/sprocs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<StoredProcedure>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new StoredProcedure();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Replace a Document
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        ///     Required. The Collection Id
        /// </param>
        /// <param name='ridDoc'>
        ///     Required. The Document Id
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request.
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.
        ///     <example>
        ///         Fri, 08 Apr 2015
        ///         03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='request'>
        ///     Optional.
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Document>> ReplaceDocumentWithOperationResponseAsync(string ridDB,
            string ridColl, string ridDoc, string authorization, string userAgent, string xMSDate, string xMSVersion,
            Document request = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"request", request},
                    {"authorization", authorization},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ReplaceDocumentAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Put,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            if (request != null)
            {
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            }
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound && statusCode != HttpStatusCode.Conflict &&
                statusCode != HttpStatusCode.RequestEntityTooLarge)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Document>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Document();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <param name='ridOffer'>
        ///     Required. The Offer Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example:
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Offer>> ReplaceOfferWithOperationResponseAsync(string ridOffer,
            ReplaceOffer request, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridOffer == null)
            {
                throw new ArgumentNullException(nameof(ridOffer));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridOffer", ridOffer},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ReplaceOfferAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/offers/";
            url = url + Uri.EscapeDataString(ridOffer);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Put,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Offer>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Offer();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Replaces the entire user Permission.
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='ridPerm'>
        ///     Required. The Permission Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example:
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format. example-
        ///     <example>
        ///         Fri, 08 Apr
        ///         2015 03:52:31 GMT
        ///     </example>
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Permission>> ReplacePermissionWithOperationResponseAsync(string ridDB,
            string ridUser, string ridPerm, Permission request, string authorization, string contentType,
            string userAgent, string xMSVersion, string xMSDate,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (ridPerm == null)
            {
                throw new ArgumentNullException(nameof(ridPerm));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridUser", ridUser},
                    {"ridPerm", ridPerm},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSVersion", xMSVersion},
                    {"xMSDate", xMSDate}
                };
                ServiceClientTracing.Enter(invocationId, this, "ReplacePermissionAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            url = url + "/permissions/";
            url = url + Uri.EscapeDataString(ridPerm);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Put,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound && statusCode != HttpStatusCode.Conflict)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<Permission>
            {
                Request = httpRequest,
                Response = httpResponse
            };

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new Permission();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     Replace a User
        /// </summary>
        /// <param name='ridDB'>
        ///     Required. The Database Id
        /// </param>
        /// <param name='ridUser'>
        ///     Required. The User Id
        /// </param>
        /// <param name='request'>
        ///     Required.
        /// </param>
        /// <param name='authorization'>
        ///     Required. The authentication type and signature token. Both master
        ///     key and resource tokens are allowed for this operation.
        ///     <c>type={typeoftoken}%26ver={tokenversion}%26sig={hashsignature}</c>
        /// </param>
        /// <param name='contentType'>
        ///     Required. Optional. For creating a database, the Content-Type
        ///     header must be application/json.
        /// </param>
        /// <param name='userAgent'>
        ///     Required. Optional. The string of client user agent performing the
        ///     request. The recommended format is
        ///     <c>
        ///         {user agent
        ///         name}/{version}
        ///     </c>
        /// </param>
        /// <param name='xMSDate'>
        ///     Required. The date of the request The date is expressed in
        ///     Coordinated Universal Time format.          example: -
        ///     <example>Fri, 08 Apr 2015 03:52:31 GMT</example>
        /// </param>
        /// <param name='xMSVersion'>
        ///     Required. The version of DocumentDB REST service. The latest
        ///     version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        ///     Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<User>> ReplaceUserWithOperationResponseAsync(string ridDB,
            string ridUser, User request, string authorization, string contentType, string userAgent, string xMSDate,
            string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridUser == null)
            {
                throw new ArgumentNullException(nameof(ridUser));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (userAgent == null)
            {
                throw new ArgumentNullException(nameof(userAgent));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }

            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridUser", ridUser},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"userAgent", userAgent},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ReplaceUserAsync", tracingParameters);
            }

            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/users/";
            url = url + Uri.EscapeDataString(ridUser);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Put,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("User-Agent", userAgent);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);

            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }

            // Serialize Request

            var requestDoc = request.SerializeJson(null);
            var requestContent = requestDoc.ToString(Formatting.Indented);
            httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest &&
                statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden &&
                statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }

            // Create Result
            var result = new HttpOperationResponse<User>();
            result.Request = httpRequest;
            result.Response = httpResponse;

            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                var resultModel = new User();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }

        /// <summary>
        ///     The base URI of the service.
        /// </summary>
        public Uri BaseUri { get; set; }

        /// <summary>
        ///     Credentials for authenticating with the service.
        /// </summary>
        public ServiceClientCredentials Credentials { get; set; }

        /// <summary>
        ///     The DocumentDB Account Name
        /// </summary>
        public string DocumentDbAccount { get; set; }
    }
}