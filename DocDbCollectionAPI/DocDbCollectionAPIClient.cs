// Code generated by Microsoft (R) AutoRest Code Generator 0.9.7.0
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using DocDbCollectionAPI.Models;
using Microsoft.Rest;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace DocDbCollectionAPI
{
    public class DocDbCollectionApiClient : ServiceClient<DocDbCollectionApiClient>, IDocDbCollectionApiClient
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public Uri BaseUri { get; set; }

        /// <summary>
        /// Credentials for authenticating with the service.
        /// </summary>
        public ServiceClientCredentials Credentials { get; set; }

        /// <summary>
        /// Initializes a new instance of the DocDbCollectionApiClient class.
        /// </summary>
        public DocDbCollectionApiClient()
        {
            BaseUri = new Uri("https://healthcare.documents.azure.com:443/dbs");
        }
        
        /// <summary>
        /// Initializes a new instance of the DocDbCollectionApiClient class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public DocDbCollectionApiClient(params DelegatingHandler[] handlers)
            : base(handlers)
        {
            BaseUri = new Uri("https://healthcare.documents.azure.com:443/dbs");
        }
        
        /// <summary>
        /// Initializes a new instance of the DocDbCollectionApiClient class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public DocDbCollectionApiClient(HttpClientHandler rootHandler, params DelegatingHandler[] handlers)
            : base(rootHandler, handlers)
        {
            BaseUri = new Uri("https://healthcare.documents.azure.com:443/dbs");
        }
        
        /// <summary>
        /// Initializes a new instance of the DocDbCollectionApiClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public DocDbCollectionApiClient(Uri baseUri, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException(nameof(baseUri));
            }
            BaseUri = baseUri;
        }
        
        /// <summary>
        /// Initializes a new instance of the DocDbCollectionApiClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Credentials for authenticating with the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public DocDbCollectionApiClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (credentials == null)
            {
                throw new ArgumentNullException(nameof(credentials));
            }
            Credentials = credentials;

            Credentials?.InitializeServiceClient(this);
        }
        
        /// <summary>
        /// Initializes a new instance of the DocDbCollectionApiClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Credentials for authenticating with the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public DocDbCollectionApiClient(Uri baseUri, ServiceClientCredentials credentials, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException(nameof(baseUri));
            }
            if (credentials == null)
            {
                throw new ArgumentNullException(nameof(credentials));
            }
            BaseUri = baseUri;
            Credentials = credentials;

            Credentials?.InitializeServiceClient(this);
        }

        /// <summary>
        /// Create an Attachment
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='ridDoc'>
        /// Required. The Document ID
        /// </param>
        /// <param name='request'>
        /// Required.
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.           example - Fri, 08 Apr
        /// 2015 03:52:31 GMT
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<AttachmentResponse>> CreateAttachementWithOperationResponseAsync(string ridDB, string ridColl, string ridDoc, Attachment request, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"request", request},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "CreateAttachementAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            url = url + "/attachments";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.Conflict && statusCode != HttpStatusCode.RequestEntityTooLarge)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<AttachmentResponse>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new AttachmentResponse();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Create a new Document
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='request'>
        /// Required.
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Document>> CreateDocumentWithOperationResponseAsync(string ridDB, string ridColl, CustomBody request, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"request", request},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "CreateDocumentAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<Document>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new Document();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Delete a Document
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='ridDoc'>
        /// Required. The Document ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeleteDocumentWithOperationResponseAsync(string ridDB, string ridColl, string ridDoc, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "DeleteDocumentAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Delete,
                RequestUri = new Uri(url)
            };

            // Set Headers
            httpRequest.Headers.Add("Authorization", authorization);
            httpRequest.Headers.Add("x-ms-date", xMSDate);
            httpRequest.Headers.Add("x-ms-version", xMSVersion);
            
            // Set Credentials
            if (Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            var statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.NoContent && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
            {
                var ex = new HttpOperationException
                {
                    Request = httpRequest,
                    Response = httpResponse,
                    Body = null
                };
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            var result = new HttpOperationResponse<object>
            {
                Request = httpRequest,
                Response = httpResponse,
                Body = null
            };

            // Deserialize Response

            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <summary>
        /// Execute a Stored Procedure
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='ridProc'>
        /// Required. The Procedure ID
        /// </param>
        /// <param name='request'>
        /// Required.
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='contentType'>
        /// Required. Required. The Content-Type header must be
        /// application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        /// Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        /// Required.
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.          example - : Fri, 08
        /// Apr 2015 03:52:31 GMT
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> ExecuteStoredProcedureWithOperationResponseAsync(string ridDB, string ridColl, string ridProc, QueryRequest request, string authorization, string contentType, bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridProc == null)
            {
                throw new ArgumentNullException(nameof(ridProc));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridProc", ridProc},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan},
                    {"xMSDocumentdbIsquery", xMSDocumentdbIsquery},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ExecuteStoredProcedureAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/sprocs/";
            url = url + Uri.EscapeDataString(ridProc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
                httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan", xMSDocumentdbQueryEnableScan.ToString().ToLower());
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<QueryResponseBody>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new QueryResponseBody();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Get an Attachment from document
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='ridDoc'>
        /// Required. The Document ID
        /// </param>
        /// <param name='ridAttch'>
        /// Required. The Attachment ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.           example - Fri, 08 Apr
        /// 2015 03:52:31 GMT
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<AttachmentRaw>> GetAttachementWithOperationResponseAsync(string ridDB, string ridColl, string ridDoc, string ridAttch, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (ridAttch == null)
            {
                throw new ArgumentNullException(nameof(ridAttch));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"ridAttch", ridAttch},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetAttachementAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            url = url + "/attachments/";
            url = url + Uri.EscapeDataString(ridAttch);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.Conflict && statusCode != HttpStatusCode.RequestEntityTooLarge)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<AttachmentRaw>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new AttachmentRaw();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Get a Document.
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='ridDoc'>
        /// Required. The Document ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Document>> GetDocumentByIdWithOperationResponseAsync(string ridDB, string ridColl, string ridDoc, string authorization, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"authorization", authorization},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "GetDocumentByIdAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<Document>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new Document();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// List Documents
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<Document>>> ListDocumentsWithOperationResponseAsync(string ridDB, string ridColl, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ListDocumentsAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<IList<Document>>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    IList<Document> resultModel = new List<Document>();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel = DocumentCollection.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Get a list of Stored Procedures for the Collection
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<StoredProcedure>>> ListStoredProceduresWithOperationResponseAsync(string ridDB, string ridColl, string authorization, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"authorization", authorization}
                };
                ServiceClientTracing.Enter(invocationId, this, "ListStoredProceduresAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/sprocs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<IList<StoredProcedure>>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    IList<StoredProcedure> resultModel = new List<StoredProcedure>();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel = StoredProcedureCollection.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Perform a document query
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<IList<Document>>> QueryDocumentsWithOperationResponseAsync(string ridDB, string ridColl, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "QueryDocumentsAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/ /";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Get,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<IList<Document>>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    IList<Document> resultModel = new List<Document>();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel = DocumentCollection.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Query a Trigger
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='contentType'>
        /// Required. Required. The Content-Type header must be
        /// application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        /// Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        /// Required.
        /// </param>
        /// <param name='request'>
        /// Required.
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.       example - Fri, 08 Apr
        /// 2015 03:52:31 GMT
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> QueryTriggerWithOperationResponseAsync(string ridDB, string ridColl, string contentType, bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery, QueryRequest request, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"contentType", contentType},
                    {"xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan},
                    {"xMSDocumentdbIsquery", xMSDocumentdbIsquery},
                    {"request", request},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "QueryTriggerAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/trigger";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
                httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan", xMSDocumentdbQueryEnableScan.ToString().ToLower());
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<QueryResponseBody>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new QueryResponseBody();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Query a UDF
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='request'>
        /// Required.
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='contentType'>
        /// Required. Required. The Content-Type header must be
        /// application/json.
        /// </param>
        /// <param name='xMSDocumentdbQueryEnableScan'>
        /// Required.
        /// </param>
        /// <param name='xMSDocumentdbIsquery'>
        /// Required.
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format. example: Fri, 08 Apr 2015
        /// 03:52:31 GMT
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<QueryResponseBody>> QueryUdfWithOperationResponseAsync(string ridDB, string ridColl, QueryRequest request, string authorization, string contentType, bool xMSDocumentdbQueryEnableScan, bool xMSDocumentdbIsquery, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (contentType == null)
            {
                throw new ArgumentNullException(nameof(contentType));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"request", request},
                    {"authorization", authorization},
                    {"contentType", contentType},
                    {"xMSDocumentdbQueryEnableScan", xMSDocumentdbQueryEnableScan},
                    {"xMSDocumentdbIsquery", xMSDocumentdbIsquery},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "QueryUdfAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/udf";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-documentdb-isquery", xMSDocumentdbIsquery.ToString().ToLower());
                httpRequest.Headers.Add("x-ms-documentdb-query-enable-scan", xMSDocumentdbQueryEnableScan.ToString().ToLower());
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<QueryResponseBody>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new QueryResponseBody();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Register/ Create a Stored Procedure
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='request'>
        /// Required.
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.          example - Fri, 08 Apr
        /// 2015 03:52:31 GMT
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<StoredProcedure>> RegisterStoredProcedureWithOperationResponseAsync(string ridDB, string ridColl, QueryRequest request, string authorization, string xMSDate, string xMSVersion, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"request", request},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "RegisterStoredProcedureAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/sprocs";
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                var requestDoc = request.SerializeJson(null);
                var requestContent = requestDoc.ToString(Formatting.Indented);
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.Created && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.RequestTimeout)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<StoredProcedure>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.Created)
                {
                    var resultModel = new StoredProcedure();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
        
        /// <summary>
        /// Replace a Document
        /// </summary>
        /// <param name='ridDB'>
        /// Required. The Database Id
        /// </param>
        /// <param name='ridColl'>
        /// Required. The Collection ID
        /// </param>
        /// <param name='ridDoc'>
        /// Required. The Document ID
        /// </param>
        /// <param name='authorization'>
        /// Required. The authentication type and signature token. Both master
        /// key and resource tokens are allowed for this operation
        /// </param>
        /// <param name='xMSDate'>
        /// Required. The date of the request The date is expressed in
        /// Coordinated Universal Time format.
        /// </param>
        /// <param name='xMSVersion'>
        /// Required. The version of DocumentDB REST service. The latest
        /// version is used when the header is not provided use 2015-08-06
        /// </param>
        /// <param name='request'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<Document>> ReplaceDocumentWithOperationResponseAsync(string ridDB, string ridColl, string ridDoc, string authorization, string xMSDate, string xMSVersion, Document request = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Validate
            if (ridDB == null)
            {
                throw new ArgumentNullException(nameof(ridDB));
            }
            if (ridColl == null)
            {
                throw new ArgumentNullException(nameof(ridColl));
            }
            if (ridDoc == null)
            {
                throw new ArgumentNullException(nameof(ridDoc));
            }
            if (authorization == null)
            {
                throw new ArgumentNullException(nameof(authorization));
            }
            if (xMSDate == null)
            {
                throw new ArgumentNullException(nameof(xMSDate));
            }
            if (xMSVersion == null)
            {
                throw new ArgumentNullException(nameof(xMSVersion));
            }
            
            // Tracing
            var shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                var tracingParameters = new Dictionary<string, object>
                {
                    {"ridDB", ridDB},
                    {"ridColl", ridColl},
                    {"ridDoc", ridDoc},
                    {"request", request},
                    {"authorization", authorization},
                    {"xMSDate", xMSDate},
                    {"xMSVersion", xMSVersion}
                };
                ServiceClientTracing.Enter(invocationId, this, "ReplaceDocumentAsync", tracingParameters);
            }
            
            // Construct URL
            var url = "";
            url = url + "/";
            url = url + Uri.EscapeDataString(ridDB);
            url = url + "/colls/";
            url = url + Uri.EscapeDataString(ridColl);
            url = url + "/docs/";
            url = url + Uri.EscapeDataString(ridDoc);
            var baseUrl = BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");

            // Create HTTP transport objects
            using (var httpRequest = new HttpRequestMessage
            {
                Method = HttpMethod.Put,
                RequestUri = new Uri(url)
            })
            {

                // Set Headers
                httpRequest.Headers.Add("Authorization", authorization);
                httpRequest.Headers.Add("x-ms-date", xMSDate);
                httpRequest.Headers.Add("x-ms-version", xMSVersion);

                // Set Credentials
                if (Credentials != null)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                }

                // Serialize Request
                if (request != null)
                {
                    var requestDoc = request.SerializeJson(null);
                    var requestContent = requestDoc.ToString(Formatting.Indented);
                    httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                }
                httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");

                // Send Request
                if (shouldTrace)
                {
                    ServiceClientTracing.SendRequest(invocationId, httpRequest);
                }
                cancellationToken.ThrowIfCancellationRequested();
                var httpResponse = await HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                if (shouldTrace)
                {
                    ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
                }
                var statusCode = httpResponse.StatusCode;
                cancellationToken.ThrowIfCancellationRequested();
                var responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.BadRequest && statusCode != HttpStatusCode.Unauthorized && statusCode != HttpStatusCode.Forbidden && statusCode != HttpStatusCode.NotFound && statusCode != HttpStatusCode.Conflict && statusCode != HttpStatusCode.RequestEntityTooLarge)
                {
                    var ex = new HttpOperationException
                    {
                        Request = httpRequest,
                        Response = httpResponse,
                        Body = null
                    };
                    if (shouldTrace)
                    {
                        ServiceClientTracing.Error(invocationId, ex);
                    }
                    throw ex;
                }

                // Create Result
                var result = new HttpOperationResponse<Document>
                {
                    Request = httpRequest,
                    Response = httpResponse
                };

                // Deserialize Response
                if (statusCode == HttpStatusCode.OK)
                {
                    var resultModel = new Document();
                    JToken responseDoc = null;
                    if (string.IsNullOrEmpty(responseContent) == false)
                    {
                        responseDoc = JToken.Parse(responseContent);
                    }
                    if (responseDoc != null)
                    {
                        resultModel.DeserializeJson(responseDoc);
                    }
                    result.Body = resultModel;
                }

                if (shouldTrace)
                {
                    ServiceClientTracing.Exit(invocationId, result);
                }
                return result;
            }
        }
    }
}
